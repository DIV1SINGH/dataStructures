[![GitHub license](https://img.shields.io/badge/license-MIT-blue.svg)](https://raw.githubusercontent.com/ashishkrishan1995/dataStructures/master/LICENSE)
[![GitHub forks](https://img.shields.io/github/forks/ashishkrishan1995/dataStructures.svg)](https://github.com/ashishkrishan1995/dataStructures/network)
[![GitHub issues](https://img.shields.io/github/issues/ashishkrishan1995/dataStructures.svg)](https://github.com/ashishkrishan1995/dataStructures/issues)
[![GitHub stars](https://img.shields.io/github/stars/ashishkrishan1995/dataStructures.svg)](https://github.com/ashishkrishan1995/dataStructures/stargazers)
# Data Structures
This repository contains the various progams on Data Structures and Algorithms using C and C++.

Further, it contains the programs which are commonly asked in the technical interviews of companies like Microsoft, Amazon, Flipkart, DE Shaw etc.

# Data structures in english
The following is a simple language explanation of a few data structures. For the sake of simplicity imagine that you have a set of Objects (small cubes or spheres or something) and that you can connect them in arbitrary ways.
## Linked Lists
A linked lists are simple data structures where each object links to the object behind and sometimes to the object in front of it. The basic idea is to line your objects up on after the other. These data structures are easy to deal with but are slow when you have sufficiently large lists. In general you can only access a linked list from the front or the back (or both) and in order to find something in it you may need to walk the entire list.

## Arrays

1D Arrays are like linked lists, but where you can access each element directly. This is great if you know what you want out of it, but no better if you need to search through until you find a match. Higher order arrays (2D, 3D, 4D, etc...) give greater granularity and can help if you can give meaningful ordering to each new dimension. ex name on dimension 1 and age on dimension 2.

## Binary Search Tree

Binary search tree is a very performant way of store data. In a binary search tree, each node is sorted, when you want to add a node, you compare the value with the root, if this value is greater than root's value, you go to the right subtree, if not, you go to the left subtree, and then you compare your node with the root of the subtree until you find the right position of insertion. With this data structure, the research of a value is very fast because you don't have to compare it with each tree's value.

## Resources
[Open Data Structures](http://opendatastructures.org/) <br>
[Data Structures on hackerearth](https://www.hackerearth.com/practice/) <br>
[Resources on Codechef](https://www.codechef.com/certification/prepare) <br>

If you found this helpful or learned something today and want to thank me, consider buying me a cup of coffee.
>  + [PayPal](https://paypal.me/ashishkrishan1995/2)

## Authors

* **Ashish Krishan** - *Initial work*
